#!/usr/bin/env pwsh

param(
    [Parameter(
            HelpMessage = "Path to the report file generated by opinionated-csharp-todos",
            Mandatory = $true)]
    [string]
    $ReportPath,

    [Parameter(
            HelpMessage = "Path to the directory containing the markdown files",
            Mandatory = $true)]
    [string]
    $OutputDir,

    [Parameter(
            HelpMessage = "Prefix to be prepended to the location of the file containg a comment")]
    [string]
    $UrlPrefix
)

<#
.SYNOPSIS
This script renders the tasks as a markdown.
#>

$nl = [Environment]::NewLine
$todoRe = [Regex]::new(' \(([^)]+), ([0-9]{4}-[0-9]{2}-[0-9]{2})\): ')

function StripMarginFromSecondLineOn([string]$Text)
{
    $lines = $Text.Split(@("`r`n", "`r", "`n"), [StringSplitOptions]::None)
    if ($lines.Count -lt 2)
    {
        return $Text
    }

    if($lines.Count -eq 2)
    {
        $lines[1] = $lines[1].TrimStart()
        return ($lines -Join $nl)
    }

    $minLength = $null
    for($i = 1; $i -lt $lines.Length; $i++)
    {
        # Empty lines are ignored since IDEs sometimes strip them away and
        # do not indent them with whitespace.
        if ($lines[$i].Length -eq 0)
        {
            continue
        }

        if (($null -eq $minLength) -or ($lines[$i].Length -lt $minLength))
        {
            $minLength = $lines[$i].Length
        }
    }

    if($null -eq $minLength)
    {
        # All lines from the second on were empty.
        return $Text
    }

    $commonMarginLength = 0
    $stop = $false
    for($cursor = 0; !$stop -and ($cursor -lt $minLength); $cursor++)
    {
        $charAtCursor = $null

        for($i = 1; !$stop -and ($i -lt $lines.Length); $i++)
        {
            # Skip empty lines, see the comment above
            if ($lines[$i].Length -eq 0)
            {
                continue
            }

            if ($null -eq $charAtCursor)
            {
                $charAtCursor = $lines[$i][$cursor]
                if (($charAtCursor -ne " ") -and ($charAtCursor -ne "`t"))
                {
                    $commonMarginLength = $cursor
                    $stop = $true
                }
            }
            else
            {
                if ($lines[$i][$cursor] -ne $charAtCursor)
                {
                    $commonMarginLength = $cursor
                    $stop = $true
                }
            }
        }
    }

    for($i = 1; $i -lt $lines.Length; $i++)
    {
        # Skip empty lines, see the comment above
        if ($lines[$i].Length -eq 0)
        {
            continue
        }
        $lines[$i] = $lines[$i].Substring($commonMarginLength)
    }

    $result = $lines -Join $nl

    return $result
}

function ParseSuffix($Suffix)
{
    $mtch = $todoRe.Match($Suffix)
    if (!$mtch.Success)
    {
        throw "Unexpected suffix not matching ${todoRe}: $Suffix"
    }

    $author = $mtch.Groups[1].Value
    $date = $mtch.Groups[2].Value

    $remainder = $Suffix.Substring($mtch.Value.Length)
    $text = StripMarginFromSecondLineOn -Text $remainder

    [hashtable]$result = @{ }
    $result.Author = $author
    $result.Date = $date
    $result.Text = $text

    return $result
}

function RenderByFile($Report)
{
    [string[]]$parts = @()

    $sorted = $Report|Sort-Object -Property "path"
    foreach ($fileRecords in $sorted)
    {
        $parts += "## $( $fileRecords.path )$nl$nl"
        foreach ($record in $fileRecords.records)
        {
            $parsed = ParseSuffix -Suffix $record.suffix

            $parts += (
            "[Line $( $record.line ), column $( $record.column )]($nl" +
                    $UrlPrefix + "/" + ($fileRecords.path -Replace "\\", "/") +
                    "#L$( $record.line + 1)$nl" +
                    "), $nl"
            )

            $parts += "$( $parsed.Author ),$nl"
            $parts += "$( $parsed.Date )$nl$nl"

            $lines = $parsed.Text.Split(@("`r`n", "`r", "`n"), [StringSplitOptions]::None)
            for($i = 0; $i -lt $lines.Length; $i++)
            {
                $parts += "    " + $lines[$i] + $nl
            }
            $parts += $nl
        }
    }

    return $parts -Join ""
}

function Main
{
    if (!(Test-Path -Path $reportPath))
    {
        throw "Could not find the report file: $reportPath"
    }

    $report = $null
    try
    {
        $report = Get-Content -Path $reportPath|ConvertFrom-Json
    }
    catch
    {
        throw "Failed to parse the report $reportPath as JSON file: $($_.Exception)"
    }

    $null = New-Item -ItemType Directory -Force -Path $OutputDir

    $byFile = RenderByFile -Report $report

    $byFilePath = Join-Path $OutputDir "task-list-by-file.md"
    Set-Content -Path $byFilePath -Value $byFile -Encoding UTF8

    Write-Host "Saved task list grouped by file to: $byFilePath"
}

Main
