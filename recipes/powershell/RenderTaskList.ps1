#!/usr/bin/env pwsh

param(
    [Parameter(
            HelpMessage = "Path to the report file generated by opinionated-csharp-todos",
            Mandatory = $true)]
    [string]
    $ReportPath,

    [Parameter(
            HelpMessage = "Path to the directory containing the markdown files",
            Mandatory = $true)]
    [string]
    $OutputDir,

    [Parameter(
            HelpMessage = "Prefix to be prepended to the location of the file containg a comment")]
    [string]
    $UrlPrefix
)

<#
.SYNOPSIS
This script renders SVG badges using shields.io service.
#>

$nl = [Environment]::NewLine
$todoRe = [Regex]::new(' \(([^)]+), ([0-9]{4}-[0-9]{2}-[0-9]{2})\): ')
$suffixWhitespaceRe = [Regex]::new('^[ \t]*')


function ParseSuffix($Suffix)
{
    $mtch = $todoRe.Match($Suffix)
    if (!$mtch.Success)
    {
        throw "Unexpected suffix not matching ${todoRe}: $Suffix"
    }

    $author = $mtch.Groups[1].Value
    $date = $mtch.Groups[2].Value
    $remainder = $Suffix.Substring($mtch.Value.Length)

    $lines = $remainder.Split(@("`r`n", "`r", "`n"), [StringSplitOptions]::None)
    if($lines.Count -lt 2)
    {
        $text = $remainder
    }
    elseif($lines.Count -eq 2)
    {
        $lines[1] = $lines[1].Trim()
        $text = $lines -Join $nl
    }
    else
    {
        $wsMtch = $suffixWhitespaceRe.Match($lines[1])
        if($wsMtch.Success)
        {
            $minMargin = $wsMtch.Value.Length

            for($i=2; $i -lt $lines.Length; $i++)
            {
                $line = $lines[$i]

                for($j = 0; ($j -lt $line.Length) -and ($j -lt $minMargin); $j++)
                {
                    $char = $line[$j]
                    if($char -ne $wsMtch.Value[$j])
                    {
                        $minMargin = $j
                    }
                }
            }
        }

        for($i = 1; $i -lt $lines.Length; $i++)
        {
            $lines[$i] = $lines[$i].Substring($minMargin)
        }
        $text = $lines -Join $nl
    }


    [hashtable]$result = @{ }
    $result.Author = $author
    $result.Date = $date
    $result.Text = $text

    return $result
}

function RenderByFile($Report)
{
    [string[]]$parts = @()

    $sorted = $Report|Sort-Object -Property "path"
    foreach ($fileRecords in $sorted)
    {
        $parts += "## $( $fileRecords.path )$nl$nl"
        foreach ($record in $fileRecords.records)
        {
            $parsed = ParseSuffix -Suffix $record.suffix

            $parts += (
            "[Line $( $record.line ), column $( $record.column )]($nl" +
                    $UrlPrefix + "/" + ($fileRecords.path -Replace "\\", "/") +
                    "#L$( $record.line + 1)$nl" +
                    "), $nl"
            )

            $parts += "$( $parsed.Author ),$nl"
            $parts += "$( $parsed.Date )$nl$nl"

            $lines = $parsed.Text.Split(@("`r`n", "`r", "`n"), [StringSplitOptions]::None)
            for($i = 0; $i -lt $lines.Length; $i++)
            {
                $parts += "    " + $lines[$i] + $nl
            }
            $parts += $nl
        }
    }

    return $parts -Join ""
}

function Main
{
    if (!(Test-Path -Path $reportPath))
    {
        throw "Could not find the report file: $reportPath"
    }

    $report = $null
    try
    {
        $report = Get-Content -Path $reportPath|ConvertFrom-Json
    }
    catch
    {
        throw "Failed to parse the report $reportPath as JSON file: $($_.Exception)"
    }

    $null = New-Item -ItemType Directory -Force -Path $OutputDir

    $byFile = RenderByFile -Report $report

    $byFilePath = Join-Path $OutputDir "task-list-by-file.md"
    Set-Content -Path $byFilePath -Value $byFile -Encoding UTF8

    Write-Host "Saved task list grouped by file to: $byFilePath"
}

Main
